// IKPA Database Schema
// AI-Powered Personal Finance Co-Pilot for Young Africans
//
// This schema defines the PostgreSQL database structure using Prisma ORM.
// Key features:
// - UUID primary keys for security and distributed systems
// - Decimal type for monetary values (avoids floating-point errors)
// - Africa-specific features: family support, ajo/susu savings
// - Multi-currency support for African currencies

generator client {
  provider = "prisma-client-js"
}

datasource db {
  provider = "postgresql"
  url      = env("DATABASE_URL")
}

// ============================================
// ENUMS
// ============================================

enum Country {
  NIGERIA
  GHANA
  KENYA
  SOUTH_AFRICA
  EGYPT
  OTHER
}

enum Currency {
  NGN // Nigerian Naira
  GHS // Ghanaian Cedi
  KES // Kenyan Shilling
  ZAR // South African Rand
  EGP // Egyptian Pound
  USD // US Dollar
}

enum EmploymentType {
  EMPLOYED
  SELF_EMPLOYED
  FREELANCER
  BUSINESS_OWNER
  STUDENT
  UNEMPLOYED
  OTHER
}

enum IncomeType {
  SALARY
  FREELANCE
  BUSINESS
  INVESTMENT
  RENTAL
  ALLOWANCE
  GIFT
  OTHER
}

enum Frequency {
  DAILY
  WEEKLY
  BIWEEKLY
  MONTHLY
  QUARTERLY
  ANNUALLY
  ONE_TIME
}

enum SavingsType {
  BANK_ACCOUNT
  MOBILE_MONEY
  CASH
  FIXED_DEPOSIT
  AJO_SUSU // Traditional African rotating savings
  COOPERATIVE
  OTHER
}

enum InvestmentType {
  STOCKS
  BONDS
  MUTUAL_FUNDS
  REAL_ESTATE
  CRYPTO
  PENSION
  OTHER
}

enum DebtType {
  BANK_LOAN
  CREDIT_CARD
  BNPL // Buy Now Pay Later
  PERSONAL_LOAN
  MORTGAGE
  STUDENT_LOAN
  BUSINESS_LOAN
  OTHER
}

enum RelationshipType {
  PARENT
  SIBLING
  EXTENDED_FAMILY
  SPOUSE
  CHILD
  FRIEND
  COMMUNITY
  OTHER
}

enum GoalCategory {
  EMERGENCY_FUND
  SAVINGS
  INVESTMENT
  DEBT_PAYOFF
  MAJOR_PURCHASE
  EDUCATION
  TRAVEL
  FAMILY
  BUSINESS
  RETIREMENT
  OTHER
}

enum GoalStatus {
  ACTIVE
  PAUSED
  COMPLETED
  CANCELLED
}

// ============================================
// SHARK AUDITOR ENUMS
// ============================================

enum SubscriptionStatus {
  ACTIVE
  ZOMBIE
  UNKNOWN
  CANCELLED
}

enum SwipeAction {
  KEEP
  CANCEL
  REVIEW_LATER
}

enum SubscriptionCategory {
  STREAMING
  TV_CABLE
  FITNESS
  CLOUD_STORAGE
  SOFTWARE
  VPN
  LEARNING
  OTHER
}

// ============================================
// AUTHENTICATION ENUMS
// ============================================

enum MfaMethod {
  TOTP // Time-based One-Time Password (Google Authenticator, etc.)
}

enum AuthEventType {
  LOGIN_SUCCESS
  LOGIN_FAILURE
  LOGOUT
  PASSWORD_RESET_REQUEST
  PASSWORD_RESET_COMPLETE
  PASSWORD_CHANGE
  MFA_ENABLED
  MFA_DISABLED
  MFA_VERIFIED
  MFA_FAILED
  ACCOUNT_LOCKED
  ACCOUNT_UNLOCKED
  EMAIL_VERIFICATION_SENT
  EMAIL_VERIFIED
  DEVICE_ADDED
  DEVICE_REMOVED
  SUSPICIOUS_ACTIVITY
  OAUTH_LINKED
}

// ============================================
// MODELS
// ============================================

/// Core user profile with authentication and preferences
model User {
  id                   String          @id @default(uuid())
  email                String          @unique
  passwordHash         String?
  name                 String
  country              Country         @default(NIGERIA)
  currency             Currency        @default(NGN)
  timezone             String          @default("Africa/Lagos")
  dateOfBirth          DateTime?
  employmentType       EmploymentType?
  onboardingCompleted  Boolean         @default(false)
  notificationsEnabled Boolean         @default(true)
  weeklyReportEnabled  Boolean         @default(true)
  lastLoginAt          DateTime?
  createdAt            DateTime        @default(now())
  updatedAt            DateTime        @updatedAt

  // OAuth providers
  googleId String? @unique
  appleId  String? @unique

  // Password reset
  passwordResetToken   String?
  passwordResetExpires DateTime?

  // Email verification
  emailVerified     Boolean   @default(false)
  emailVerifiedAt   DateTime?

  // Password security
  passwordChangedAt DateTime?

  // Relations
  incomeSources      IncomeSource[]
  expenses           Expense[]
  savingsAccounts    SavingsAccount[]
  investments        Investment[]
  debts              Debt[]
  familySupport      FamilySupport[]
  goals              Goal[]
  snapshots          FinancialSnapshot[]
  refreshTokens      RefreshToken[]
  aiConversations    AIConversation[]
  subscriptions      Subscription[]
  emailVerifications EmailVerification[]
  mfaConfig          MfaConfig?
  sessions           UserSession[]
  budgets                Budget[]
  recoverySessions       RecoverySession[]
  savingsRateAdjustments SavingsRateAdjustment[]
  categoryFreezes        CategoryFreeze[]
  gpsAnalyticsEvents     GpsAnalyticsEvent[]
  commitmentContracts    CommitmentContract[]
  invitedReferees        CommitmentReferee[]

  @@index([email])
  @@index([country])
  @@map("users")
}

/// JWT refresh tokens for authentication
model RefreshToken {
  id        String   @id @default(uuid())
  token     String   @unique
  userId    String
  expiresAt DateTime
  createdAt DateTime @default(now())

  // Device tracking
  deviceFingerprint String?
  ipAddress         String?
  userAgent         String?

  user    User         @relation(fields: [userId], references: [id], onDelete: Cascade)
  session UserSession?

  @@index([userId])
  @@index([token])
  @@index([expiresAt])
  @@map("refresh_tokens")
}

/// Income sources - salary, freelance, business, etc.
model IncomeSource {
  id                 String     @id @default(uuid())
  userId             String
  name               String
  type               IncomeType
  amount             Decimal    @db.Decimal(15, 2)
  currency           Currency   @default(NGN)
  frequency          Frequency
  variancePercentage Int        @default(0) // For irregular income tracking
  description        String?
  isActive           Boolean    @default(true)
  startDate          DateTime   @default(now())
  endDate            DateTime?
  createdAt          DateTime   @default(now())
  updatedAt          DateTime   @updatedAt

  user User @relation(fields: [userId], references: [id], onDelete: Cascade)

  @@index([userId])
  @@index([userId, isActive])
  @@map("income_sources")
}

/// System and custom expense categories
model ExpenseCategory {
  id        String   @id @default(uuid())
  name      String
  icon      String
  color     String
  isDefault Boolean  @default(false)
  sortOrder Int      @default(0)
  createdAt DateTime @default(now())

  expenses        Expense[]
  budgets         Budget[]
  categoryFreezes CategoryFreeze[]

  @@map("expense_categories")
}

/// Individual expense transactions
model Expense {
  id          String     @id @default(uuid())
  userId      String
  categoryId  String
  amount      Decimal    @db.Decimal(15, 2)
  currency    Currency   @default(NGN)
  date        DateTime
  description String?
  merchant    String?
  isRecurring Boolean    @default(false)
  frequency   Frequency?
  createdAt   DateTime   @default(now())
  updatedAt   DateTime   @updatedAt

  user     User            @relation(fields: [userId], references: [id], onDelete: Cascade)
  category ExpenseCategory @relation(fields: [categoryId], references: [id])

  @@index([userId])
  @@index([userId, date])
  @@index([userId, categoryId])
  @@index([userId, isRecurring])
  @@map("expenses")
}

/// Savings accounts - bank, mobile money, ajo/susu
model SavingsAccount {
  id              String      @id @default(uuid())
  userId          String
  name            String
  type            SavingsType
  balance         Decimal     @db.Decimal(15, 2)
  currency        Currency    @default(NGN)
  interestRate    Decimal?    @db.Decimal(5, 2)
  institution     String?
  accountNumber   String? // Last 4 digits only for security
  isEmergencyFund Boolean     @default(false)
  isActive        Boolean     @default(true)
  createdAt       DateTime    @default(now())
  updatedAt       DateTime    @updatedAt

  user User @relation(fields: [userId], references: [id], onDelete: Cascade)

  @@index([userId])
  @@index([userId, isActive])
  @@map("savings_accounts")
}

/// Investment holdings - stocks, crypto, real estate, etc.
model Investment {
  id           String         @id @default(uuid())
  userId       String
  name         String
  type         InvestmentType
  value        Decimal        @db.Decimal(15, 2)
  currency     Currency       @default(NGN)
  costBasis    Decimal?       @db.Decimal(15, 2)
  institution  String?
  notes        String?
  isActive     Boolean        @default(true)
  purchaseDate DateTime?
  createdAt    DateTime       @default(now())
  updatedAt    DateTime       @updatedAt

  user User @relation(fields: [userId], references: [id], onDelete: Cascade)

  @@index([userId])
  @@index([userId, isActive])
  @@map("investments")
}

/// Debt obligations - loans, credit cards, BNPL
model Debt {
  id               String   @id @default(uuid())
  userId           String
  name             String
  type             DebtType
  originalAmount   Decimal  @db.Decimal(15, 2)
  remainingBalance Decimal  @db.Decimal(15, 2)
  currency         Currency @default(NGN)
  interestRate     Decimal  @db.Decimal(5, 2)
  minimumPayment   Decimal  @db.Decimal(15, 2)
  dueDate          Int? // Day of month (1-31)
  institution      String?
  notes            String?
  isActive         Boolean  @default(true)
  startDate        DateTime
  targetPayoffDate DateTime?
  createdAt        DateTime @default(now())
  updatedAt        DateTime @updatedAt

  user User @relation(fields: [userId], references: [id], onDelete: Cascade)

  @@index([userId])
  @@index([userId, isActive])
  @@map("debts")
}

/// Family support obligations - unique to African context
model FamilySupport {
  id           String           @id @default(uuid())
  userId       String
  name         String // "Mom", "Brother Emeka", etc.
  relationship RelationshipType
  amount       Decimal          @db.Decimal(15, 2)
  currency     Currency         @default(NGN)
  frequency    Frequency
  description  String?
  isActive     Boolean          @default(true)
  startDate    DateTime         @default(now())
  endDate      DateTime?
  createdAt    DateTime         @default(now())
  updatedAt    DateTime         @updatedAt

  user User @relation(fields: [userId], references: [id], onDelete: Cascade)

  @@index([userId])
  @@index([userId, isActive])
  @@map("family_support")
}

/// Financial goals with progress tracking
model Goal {
  id            String       @id @default(uuid())
  userId        String
  name          String
  description   String?
  category      GoalCategory
  targetAmount  Decimal      @db.Decimal(15, 2)
  currentAmount Decimal      @db.Decimal(15, 2) @default(0)
  currency      Currency     @default(NGN)
  targetDate    DateTime?
  priority      Int          @default(0)
  status        GoalStatus   @default(ACTIVE)
  createdAt     DateTime     @default(now())
  updatedAt     DateTime     @updatedAt

  user             User                 @relation(fields: [userId], references: [id], onDelete: Cascade)
  contributions    GoalContribution[]
  recoverySessions RecoverySession[]
  commitments      CommitmentContract[]

  @@index([userId])
  @@index([userId, status])
  @@map("goals")
}

/// Goal contribution history
model GoalContribution {
  id        String   @id @default(uuid())
  goalId    String
  amount    Decimal  @db.Decimal(15, 2)
  date      DateTime @default(now())
  note      String?
  createdAt DateTime @default(now())

  goal Goal @relation(fields: [goalId], references: [id], onDelete: Cascade)

  @@index([goalId])
  @@index([goalId, date])
  @@map("goal_contributions")
}

/// Point-in-time financial metrics snapshot
model FinancialSnapshot {
  id              String   @id @default(uuid())
  userId          String
  date            DateTime @default(now())

  // Core metrics (values)
  cashFlowScore   Int // 0-100 final weighted score
  savingsRate     Decimal  @db.Decimal(5, 2) // percentage
  runwayMonths    Decimal  @db.Decimal(5, 2) // months of emergency fund
  burnRate        Decimal  @db.Decimal(15, 2) // monthly expenses + debt payments
  dependencyRatio Decimal  @db.Decimal(5, 2) // % of income supporting others
  debtToIncome    Decimal  @db.Decimal(5, 2) @default(0) // % of income going to debt
  incomeStability Decimal  @db.Decimal(5, 2) @default(0) // coefficient of variation

  // Individual component scores (0-100 each)
  // Stored to avoid data loss when reconstructing from cache
  savingsRateScore     Int @default(0)
  runwayMonthsScore    Int @default(0)
  debtToIncomeScore    Int @default(0)
  incomeStabilityScore Int @default(0)
  dependencyRatioScore Int @default(0)

  // Totals
  netWorth      Decimal  @db.Decimal(15, 2)
  totalIncome   Decimal  @db.Decimal(15, 2)
  totalExpenses Decimal  @db.Decimal(15, 2)
  totalSavings  Decimal  @db.Decimal(15, 2)
  totalDebt     Decimal  @db.Decimal(15, 2)
  totalAssets   Decimal  @db.Decimal(15, 2)
  totalSupport  Decimal  @db.Decimal(15, 2)

  currency  Currency @default(NGN)
  createdAt DateTime @default(now())

  user User @relation(fields: [userId], references: [id], onDelete: Cascade)

  @@unique([userId, date]) // Prevent duplicate snapshots for same user/day
  @@index([userId])
  @@index([userId, date])
  @@index([date]) // For cron job cleanup queries
  @@map("financial_snapshots")
}

/// AI conversation containers
model AIConversation {
  id        String   @id @default(uuid())
  userId    String
  title     String?
  createdAt DateTime @default(now())
  updatedAt DateTime @updatedAt

  user     User        @relation(fields: [userId], references: [id], onDelete: Cascade)
  messages AIMessage[]

  @@index([userId])
  @@index([userId, updatedAt])
  @@map("ai_conversations")
}

/// Individual AI chat messages
model AIMessage {
  id             String   @id @default(uuid())
  conversationId String
  role           String // 'user' | 'assistant'
  content        String   @db.Text
  createdAt      DateTime @default(now())

  conversation AIConversation @relation(fields: [conversationId], references: [id], onDelete: Cascade)

  @@index([conversationId])
  @@map("ai_messages")
}

/// Landing page waitlist entries
model WaitlistEntry {
  id           String   @id @default(uuid())
  email        String   @unique
  name         String?
  country      Country?
  referralCode String   @unique
  referredBy   String?
  source       String?
  createdAt    DateTime @default(now())

  @@index([email])
  @@index([referralCode])
  @@map("waitlist_entries")
}

// ============================================
// SHARK AUDITOR MODELS
// ============================================

/// Detected subscription from expense analysis
model Subscription {
  id              String               @id @default(uuid())
  userId          String
  name            String
  merchantPattern String?              // Original merchant name that matched
  category        SubscriptionCategory
  monthlyCost     Decimal              @db.Decimal(15, 2)
  annualCost      Decimal              @db.Decimal(15, 2)
  currency        Currency             @default(NGN)
  status          SubscriptionStatus   @default(UNKNOWN)
  lastUsageDate   DateTime?
  detectedAt      DateTime             @default(now())
  firstChargeDate DateTime?
  lastChargeDate  DateTime?
  chargeCount     Int                  @default(0)
  isActive        Boolean              @default(true)
  createdAt       DateTime             @default(now())
  updatedAt       DateTime             @updatedAt

  user           User           @relation(fields: [userId], references: [id], onDelete: Cascade)
  swipeDecisions SwipeDecision[]

  @@unique([userId, merchantPattern], name: "unique_user_merchant")
  @@index([userId])
  @@index([userId, status])
  @@index([userId, isActive])
  @@map("subscriptions")
}

/// User swipe decision on a subscription
model SwipeDecision {
  id             String      @id @default(uuid())
  subscriptionId String
  userId         String
  action         SwipeAction
  reason         String?     // Optional reason for the decision (e.g., cancellation reason)
  decidedAt      DateTime    @default(now())
  createdAt      DateTime    @default(now())

  subscription Subscription @relation(fields: [subscriptionId], references: [id], onDelete: Cascade)

  @@index([subscriptionId])
  @@index([userId])
  @@index([userId, action])
  @@map("swipe_decisions")
}

// ============================================
// AUTHENTICATION MODELS
// ============================================

/// Email verification tokens for new registrations
model EmailVerification {
  id        String   @id @default(uuid())
  userId    String
  token     String   @unique // Hashed token (SHA256)
  expiresAt DateTime
  createdAt DateTime @default(now())

  user User @relation(fields: [userId], references: [id], onDelete: Cascade)

  @@index([userId])
  @@index([token])
  @@index([expiresAt])
  @@map("email_verifications")
}

/// Multi-factor authentication configuration per user
model MfaConfig {
  id          String    @id @default(uuid())
  userId      String    @unique
  method      MfaMethod @default(TOTP)
  secret      String    // Encrypted TOTP secret
  isEnabled   Boolean   @default(false)
  backupCodes String[]  // Hashed backup codes
  verifiedAt  DateTime? // When MFA was first verified
  lastUsedAt  DateTime?
  createdAt   DateTime  @default(now())
  updatedAt   DateTime  @updatedAt

  user User @relation(fields: [userId], references: [id], onDelete: Cascade)

  @@map("mfa_configs")
}

/// Track login attempts for account lockout protection
model LoginAttempt {
  id        String   @id @default(uuid())
  email     String   // Email used (not userId - user may not exist)
  ipAddress String
  userAgent String?
  success   Boolean
  reason    String?  // Failure reason code
  createdAt DateTime @default(now())

  @@index([email])
  @@index([ipAddress])
  @@index([email, createdAt])
  @@index([createdAt])
  @@map("login_attempts")
}

/// Account lockout tracking
model AccountLockout {
  id          String    @id @default(uuid())
  email       String    @unique
  lockedAt    DateTime  @default(now())
  lockedUntil DateTime
  attempts    Int       @default(0)
  reason      String    @default("FAILED_LOGIN_ATTEMPTS")
  unlockedAt  DateTime?
  unlockedBy  String?   // Admin user ID if manually unlocked

  @@index([email])
  @@index([lockedUntil])
  @@map("account_lockouts")
}

/// Active user sessions with device info
model UserSession {
  id             String   @id @default(uuid())
  userId         String
  refreshTokenId String   @unique // Links to RefreshToken.id
  deviceName     String?  // "iPhone 15 Pro", "Chrome on MacOS"
  deviceType     String?  // "mobile", "desktop", "tablet"
  browser        String?
  os             String?
  ipAddress      String
  location       String?  // City, Country from IP geolocation
  lastActiveAt   DateTime @default(now())
  createdAt      DateTime @default(now())

  user         User         @relation(fields: [userId], references: [id], onDelete: Cascade)
  refreshToken RefreshToken @relation(fields: [refreshTokenId], references: [id], onDelete: Cascade)

  @@index([userId])
  @@index([refreshTokenId])
  @@index([lastActiveAt])
  @@map("user_sessions")
}

/// Security audit log for compliance and monitoring
model AuthAuditLog {
  id        String        @id @default(uuid())
  userId    String?       // Nullable for failed logins with non-existent users
  email     String?       // For tracking attempts on non-existent accounts
  eventType AuthEventType
  ipAddress String
  userAgent String?
  metadata  Json?         // Additional event-specific data
  success   Boolean       @default(true)
  createdAt DateTime      @default(now())

  @@index([userId])
  @@index([email])
  @@index([eventType])
  @@index([createdAt])
  @@index([userId, eventType, createdAt])
  @@map("auth_audit_logs")
}

// ============================================
// GPS RE-ROUTER ENUMS
// ============================================

enum BudgetPeriod {
  WEEKLY
  MONTHLY
  QUARTERLY
  ANNUALLY
}

enum RecoveryStatus {
  PENDING
  PATH_SELECTED
  IN_PROGRESS
  COMPLETED
  ABANDONED
}

// ============================================
// GPS RE-ROUTER MODELS
// ============================================

/// Budget tracking per category for GPS Re-Router
/// Allows users to set spending limits and detect overspending
model Budget {
  id         String       @id @default(uuid())
  userId     String
  categoryId String
  amount     Decimal      @db.Decimal(15, 2)
  currency   Currency     @default(NGN)
  period     BudgetPeriod @default(MONTHLY)
  startDate  DateTime     @default(now())
  isActive   Boolean      @default(true)
  createdAt  DateTime     @default(now())
  updatedAt  DateTime     @updatedAt

  user     User            @relation(fields: [userId], references: [id], onDelete: Cascade)
  category ExpenseCategory @relation(fields: [categoryId], references: [id])

  @@unique([userId, categoryId, period])
  @@index([userId])
  @@index([userId, isActive])
  @@map("budgets")
}

/// Recovery session tracking for GPS Re-Router
/// Tracks when users exceed budgets and which recovery path they select
model RecoverySession {
  id                  String         @id @default(uuid())
  userId              String
  goalId              String?
  budgetId            String?
  category            String
  overspendAmount     Decimal        @db.Decimal(15, 2)
  previousProbability Decimal        @db.Decimal(5, 4)
  newProbability      Decimal        @db.Decimal(5, 4)
  selectedPathId      String?
  selectedAt          DateTime?
  actionExecutedAt    DateTime?      // When the recovery action was actually executed
  status              RecoveryStatus @default(PENDING)
  createdAt           DateTime       @default(now())
  updatedAt           DateTime       @updatedAt

  user            User                 @relation(fields: [userId], references: [id], onDelete: Cascade)
  goal            Goal?                @relation(fields: [goalId], references: [id])
  analyticsEvents GpsAnalyticsEvent[]

  @@index([userId])
  @@index([userId, status])
  @@map("recovery_sessions")
}

/// Temporary savings rate adjustment for GPS Re-Router
/// Tracks when users commit to temporarily increasing their savings rate
model SavingsRateAdjustment {
  id               String   @id @default(uuid())
  userId           String
  sessionId        String
  additionalRate   Decimal  @db.Decimal(5, 4) // e.g., 0.05 for 5%
  durationWeeks    Int
  startDate        DateTime @default(now())
  endDate          DateTime
  isActive         Boolean  @default(true)
  originalRate     Decimal  @db.Decimal(5, 4)
  createdAt        DateTime @default(now())
  updatedAt        DateTime @updatedAt

  user User @relation(fields: [userId], references: [id], onDelete: Cascade)

  @@index([userId])
  @@index([userId, isActive])
  @@index([endDate])
  @@map("savings_rate_adjustments")
}

/// Category spending freeze for GPS Re-Router
/// Tracks when users commit to pausing spending in a category
model CategoryFreeze {
  id            String   @id @default(uuid())
  userId        String
  sessionId     String
  categoryId    String
  categoryName  String
  durationWeeks Int
  startDate     DateTime @default(now())
  endDate       DateTime
  isActive      Boolean  @default(true)
  savedAmount   Decimal  @db.Decimal(15, 2) // Estimated savings
  createdAt     DateTime @default(now())
  updatedAt     DateTime @updatedAt

  user     User            @relation(fields: [userId], references: [id], onDelete: Cascade)
  category ExpenseCategory @relation(fields: [categoryId], references: [id])

  @@index([userId])
  @@index([userId, isActive])
  @@index([categoryId])
  @@index([endDate])
  @@map("category_freezes")
}

/// GPS Analytics Event for tracking metrics
/// Tracks key metrics: path selections, goal survival, recovery times
model GpsAnalyticsEvent {
  id              String   @id @default(uuid())
  userId          String
  sessionId       String?
  eventType       GpsEventType
  eventData       Json?
  previousValue   Decimal? @db.Decimal(15, 4)
  newValue        Decimal? @db.Decimal(15, 4)
  createdAt       DateTime @default(now())

  user    User             @relation(fields: [userId], references: [id], onDelete: Cascade)
  session RecoverySession? @relation(fields: [sessionId], references: [id])

  @@index([userId])
  @@index([userId, eventType])
  @@index([sessionId])
  @@index([createdAt])
  @@map("gps_analytics_events")
}

enum GpsEventType {
  PATH_SELECTED
  GOAL_SURVIVED       // User didn't abandon goal after slip
  GOAL_ABANDONED      // User abandoned goal after slip
  RECOVERY_STARTED
  RECOVERY_COMPLETED
  PROBABILITY_RESTORED
  BUDGET_THRESHOLD_CROSSED
}

// ============================================
// COMMITMENT DEVICE ENGINE ENUMS
// ============================================

enum StakeType {
  SOCIAL        // Social accountability with referee
  ANTI_CHARITY  // Donate to opposing cause if failed
  LOSS_POOL     // Funds locked until goal achieved
}

enum VerificationMethod {
  SELF_REPORT    // User self-reports completion
  REFEREE_VERIFY // Referee must verify completion
  AUTO_DETECT    // Automatic detection (future feature)
}

enum CommitmentStatus {
  ACTIVE               // Commitment is active
  PENDING_VERIFICATION // Awaiting referee verification
  SUCCEEDED            // Goal achieved, commitment fulfilled
  FAILED               // Deadline passed without success
  CANCELLED            // User cancelled before deadline
}

enum RefereeRelationship {
  FRIEND
  FAMILY
  COLLEAGUE
  COACH
}

enum FundLockStatus {
  LOCKED     // Funds are currently locked
  RELEASED   // Funds released on success
  FORFEITED  // Funds forfeited on failure
  REFUNDED   // Funds refunded on cancellation
}

enum CommitmentAuditAction {
  CREATED              // Commitment created
  UPDATED              // Commitment updated (deadline, stake, etc.)
  CANCELLED            // Commitment cancelled
  VERIFICATION_REQUESTED // Verification requested from referee
  VERIFIED_SUCCESS     // Referee verified as success
  VERIFIED_FAILED      // Referee verified as failure
  DEADLINE_EXTENDED    // Deadline was extended
  STAKE_INCREASED      // Stake amount increased
  FUNDS_LOCKED         // Funds were locked
  FUNDS_RELEASED       // Funds were released
  FUNDS_FORFEITED      // Funds were forfeited
  FUNDS_REFUNDED       // Funds were refunded (partial or full)
  ENFORCEMENT_TRIGGERED // Cron job triggered enforcement
}

// ============================================
// COMMITMENT DEVICE ENGINE MODELS
// ============================================

/// Commitment contract - the core commitment with stakes
/// Users can commit to their goals with real consequences
model CommitmentContract {
  id                  String             @id @default(uuid())
  userId              String
  goalId              String
  idempotencyKey      String?            @unique // Client-provided key to prevent duplicates
  stakeType           StakeType
  stakeAmount         Decimal?           @db.Decimal(15, 2)
  antiCharityCause    String?            // Name of the opposing cause
  antiCharityUrl      String?            // URL for the anti-charity
  verificationMethod  VerificationMethod
  deadline            DateTime
  originalDeadline    DateTime?          // Original deadline before any extensions
  maxDeadline         DateTime?          // Maximum allowed deadline (original + 90 days)
  status              CommitmentStatus   @default(ACTIVE)
  failedAt            DateTime?
  succeededAt         DateTime?
  verifiedById        String?            // Referee who verified (if any)
  verifiedAt          DateTime?
  lastReminderSentAt  DateTime?          // Track when last reminder was sent
  refundedAmount      Decimal?           @db.Decimal(15, 2) // Amount refunded on cancellation
  createdAt           DateTime           @default(now())
  updatedAt           DateTime           @updatedAt

  user       User                    @relation(fields: [userId], references: [id], onDelete: Cascade)
  goal       Goal                    @relation(fields: [goalId], references: [id], onDelete: Cascade)
  referee    CommitmentReferee?      @relation(fields: [verifiedById], references: [id], onDelete: SetNull)
  fundLocks  CommitmentFundLock[]
  auditLogs  CommitmentAuditLog[]

  @@index([userId])
  @@index([goalId])
  @@index([userId, status])
  @@index([status, deadline])
  @@index([verifiedById, status])
  @@map("commitment_contracts")
}

/// Commitment referee - accountability partner who can verify goals
model CommitmentReferee {
  id                String              @id @default(uuid())
  email             String
  name              String
  relationship      RefereeRelationship
  invitedById       String
  inviteToken       String?             @unique
  inviteExpires     DateTime?
  acceptedAt        DateTime?
  isActive          Boolean             @default(false)
  createdAt         DateTime            @default(now())
  updatedAt         DateTime            @updatedAt

  invitedBy        User                   @relation(fields: [invitedById], references: [id], onDelete: Cascade)
  contracts        CommitmentContract[]
  verifications    CommitmentVerification[]

  @@unique([email, invitedById])
  @@index([email])
  @@index([invitedById])
  @@map("commitment_referees")
}

/// Verification record - tracks referee verification decisions
model CommitmentVerification {
  id          String   @id @default(uuid())
  contractId  String
  refereeId   String
  decision    Boolean  // true = succeeded, false = failed
  notes       String?
  verifiedAt  DateTime @default(now())
  createdAt   DateTime @default(now())

  referee  CommitmentReferee @relation(fields: [refereeId], references: [id], onDelete: Cascade)

  @@index([contractId])
  @@index([refereeId])
  @@map("commitment_verifications")
}

/// Fund lock record - persistent storage for locked funds (replaces in-memory Map)
model CommitmentFundLock {
  id              String          @id @default(uuid())
  contractId      String
  paymentLockId   String          // External payment provider lock ID
  amount          Decimal         @db.Decimal(15, 2)
  currency        String          @default("NGN")
  status          FundLockStatus  @default(LOCKED)
  lockedAt        DateTime        @default(now())
  releasedAt      DateTime?
  forfeitedAt     DateTime?
  refundedAt      DateTime?
  refundAmount    Decimal?        @db.Decimal(15, 2) // For partial refunds
  createdAt       DateTime        @default(now())
  updatedAt       DateTime        @updatedAt

  contract CommitmentContract @relation(fields: [contractId], references: [id], onDelete: Cascade)

  @@unique([contractId, status]) // Only one active lock per contract
  @@index([contractId])
  @@index([status])
  @@map("commitment_fund_locks")
}

/// Audit log - tracks all commitment lifecycle events for compliance
model CommitmentAuditLog {
  id              String                @id @default(uuid())
  contractId      String
  action          CommitmentAuditAction
  performedBy     String?               // User ID or "system" for cron jobs
  previousStatus  CommitmentStatus?
  newStatus       CommitmentStatus?
  previousAmount  Decimal?              @db.Decimal(15, 2)
  newAmount       Decimal?              @db.Decimal(15, 2)
  metadata        Json?                 // Additional context (e.g., reason, notes)
  ipAddress       String?
  userAgent       String?
  createdAt       DateTime              @default(now())

  contract CommitmentContract @relation(fields: [contractId], references: [id], onDelete: Cascade)

  @@index([contractId])
  @@index([action])
  @@index([performedBy])
  @@index([createdAt])
  @@map("commitment_audit_logs")
}
